---
layout: default
title: "3일차"
tags: 모각코
comments : true
---

## 2019.01.06 ( 3일차 )

## <center>📝 계획 📝</center>  

- [ ] 알고리즘
    - [x] using sort() method
    - [x] heap sort

***
정렬 관련 라이브러리 이미 존재

```go
#include <iostream>
#include <algorithm>

using namespace std;

int main(void) {
    int a 10] = {9, 3, 5, 4, 1, 10, 8, 6, 7, 2};
    sort(a, a+10);
    for (int i = 0 ; i <10 ; i++){
        cout << a[i] << ' ';
    }
}
```

정렬 기준 세우기

```go
bool compare(int a, int b){
    return a < b;
}

int main(void){
    sort(a, a+10, compare);
}
```

데이터 묶어서 정렬하기 : 객체로 정리
```go
#include <iostream>
#include <algorithm>

using namespace std;

class Student{
    public:
        string  name;
        int     score;
        Sudent (string name, int score){
            this -> name = name;
            this -> score = score;
        }
        bool operator < (Student &student){
            return this -> score < student.score;
        }
}

int main(void){
    Student students[] = {
        Student("AAA", 90);
        Student("BBB", 90);
        Student("CCC", 90);
        Student("DDD", 90);
        Student("FFF", 90);
    };
    sort(students, students + 5);
}

```
pair 라이브러리 사용

```go
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main(void){
    vector<pair <int, string> > v;
    v.push_back(pair<int,string> (90, "AAA"));
    v.push_back(pair<int,string> (85, "BBB"));
    v.push_back(pair<int,string> (82, "CCC"));
    v.push_back(pair<int,string> (98, "DDD"));
    v.push_back(pair<int,string> (79, "FFF"));

    for(int i = 0 ; i <v.size() ; i++){
        cout << v[i].second << ' ';
    }
    return 0;
}
```

- 변수가 3개일 때? : 2개의 변수를 기준으로, 이중 <pair> 사용
    : 성적순 나열, 동일한 성적일 때 : 나이가 어린 학생을 더 우선시

```go
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

bool compare (pair<string, pair<int,int> > a,
              pair<string, pair<int,int> > b){
    if(a.second.first == b.second.first){
        return a.second.second > b.second.second;
    }
    else{
        return a.second.first > b.second.first;
    }
}

int main(void){
   vector<pair<string, pair<int,int> > > v;
   v.push_back(pair<string, pair<int,int> >("AAA", pair<int, int> (90, 19961222)));
   v.push_back(pair<string, pair<int,int> >("AAA", pair<int, int> (97, 19930518)));
   v.push_back(pair<string, pair<int,int> >("AAA", pair<int, int> (95, 19930203)));
   v.push_back(pair<string, pair<int,int> >("AAA", pair<int, int> (90, 19921207)));
   v.push_back(pair<string, pair<int,int> >("AAA", pair<int, int> (88, 19900302)));
   sort(v.begin(), v.end(), compare);
    for(int i = 0 ; i < v.size() ; i++){
        cout << v[i].second << ' ';
    }
    return 0;
}
```

- Heap Sort
: 힙 트리 구조 이용, Heap 을 이용해 데이터 정렬하기
힙과 이진 트리 이해하기

1. 이진 트리 (Binary Tree)
node(data) 를 2개씩 이어 붙이는 구조,
모든 노드의 자식노드가 2개 이하인 트리 구조


2. Heap

완전 이진트리의 표현 : 배열에 삽입하기

|  index  |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   data  |   7   |   6   |   5   |   8   |   3   |   5   |   9   |   1   |   6   |




- Heap Sort 구현하기
```go
#include <studio.h>
int number = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main(void){
    // 전체 트리 구조를 최대 힙 구조로 바꾸기
    for (int i = 0 ; i < number ; i++){
        int c = i;
        do{
            int root = (c - 1) / 2;
            if(heap[root] < heap[c]>){
                int temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            c = root;
        }
        while (c != 0);
    }
    // 크기를 줄여가며 반복적으로 힙 구성하기
    for (int i = number - 1 ; i >= 0 ; i--){
        int temp = heap[0];
        heap[0] = heap[i];
        heap[i] = temp;
        int root = 0;
        int c = 1;
        do {
            c = 2 * root + 1;
            // 자식 중에 더 큰 값 찾기
            if (heap[c] < heap[c+1] && c < i-1){
                c++;
            }
            // root 보다 자식이 더 크다면 교환
            if (heap[root] < heap[c] && c < i>){
                int temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            root = c;
        }
        while (c < i);
    }
    for (int i = 0 ; i < number ; i++){
        printf("%d ", heap[i]);
    }
}
```
( 퀵정렬이 평균적으로 더 빠르기 때문에 힙정렬은 일반적으로 많이 사용하지는 않는다.)