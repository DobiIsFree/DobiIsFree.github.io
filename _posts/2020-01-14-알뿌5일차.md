---
layout: default
title: "5일차"
tags: 모각코
comments : true
---

## 2019.01.14 ( 5일차 )

## <center>📝 계획 📝</center>  

- [ ] 알고리즘
    - [ ] Breath First Search
    - [ ] Depth First Search
    - [ ] Union-Find

***

## Breath First Search : 너비 우선 탐색

> 탐색 할 때, 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘
맹목적인 탐색을 하고자 할 때 사용
* 너비 우선 탐색은 '최단 경로'를 찾아준다는 점에서 최단 길이를 보장해야 할 때 많이 사용

BFS 는 맨 처음에 시작 노드 (Start Node)를 큐에 삽입하면서 시작.  
시작 노드를 방문했다고 '방문 처리'를 해주도록 한다.  

1. 큐에서 하나의 노드를 꺼낸다
2. 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입한다.  
( 위 과정을 반복 )  
가까운 노드들부터 탐색이 이루어진다.

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day5/BFS.png?raw=true" width="500" height="500"></center>

> 탐색이 이루어지는 순서 = 1, 2, 3, 4, 5, 6, 7


```go

#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int number = 7;
int c[7];
vector<int> a[8];

void bfs(int start){
    queue<int> q;
    q.push(start);
    c[start] = true;
    while(!q.empth()){
        int x = q.front();
        q.pop();
        printf("%d ", x);
        for (int i = 0 ; i <a[x].size() ; i++){
            int y = a[x][i];
            if(!c[y]){
                q.push(y);
                c[y] = true;
            }
        }
    }
}

int main(void){
    /* 1과 2 연결 */
    a[1].push_back(2);
    a[2].push_back(1);
    /* 1과 3 연결 */
    a[1].push_back(3);
    a[3].push_back(1);
    /* 2와 3 연결 */
    a[2].push_back(3);
    a[3].push_back(2);
    /* 2와 4 연결 */
    a[2].push_back(4);
    a[4].push_back(2);
    /* 2와 5 연결 */
    a[2].push_back(5);
    a[5].push_back(2);
    /* 3과 6 연결 */
    a[3].push_back(6);
    a[6].push_back(3);
    /* 3과 7 연결 */
    a[3].push_back(7);
    a[7].push_back(3);
    /* 4와 5 연결 */
    a[4].push_back(5);
    a[5].push_back(4);
    /* 6과 7 연결 */
    a[6].push_back(7);
    a[7].push_back(6);
    /* BFS 수행 */
    bfs(1);
    return 0;
}

```

BFS 는 너비를 우선으로 하여 탐색한다는 특성이 중요!, 이를 이용해 다른 알고리즘에 적용한다는 것이 핵심 (BFS는 그 자체로는 큰 의미가 없다)

<br>

## Depth First Search

깊이 우선 탐색은 탐색을 함에 있어 깊은 것을 우선적으로 하여 탐색하는 알고리즘.  
맹목적으로 각 노드를 탐색할 때 주로 사용, 너비 우선 탐색에서 큐가 사용되었다면 깊이 우선 탐색에서는 '스택' 사용 (스택을 사용하지 않아도 구현 가능 : 컴퓨터는 구조적으로 항상 스택의 원리 사용)

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day5/BFS.png?raw=true" width="500" height="500"></center>

DFS는 맨 처음 시작 노드를 스택에 삽입하면서 시작.  
그와 동시에 시작 노드를 방문했다고 알리는 '방문처리'를 해준다.  

1. 스택의 최상단 노드 확인
2. 최상단 노드에게 방문하지 않은 인접 노드가 있다면 그 노드를 스택에 넣고 방문처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드르 뺀다.  
( 반복 수행 )  

> 방문 경로 : 1, 2, 3, 6, 7, 4, 5

```go

#include <iostream>
#include <vector>

using namespace std;

int number = 7;
int c[8];
voector<int> a[8];

void dfs(int x){
    if(c[x]) return;
    c[x] = true;
    cout << x << ' ';
    for (int i = 0 ; i < a[x].size(); i++){
        int y = a[x][i];
        dfs(y);
    }
}

int main(void){
    /* 1과 2 연결 */
    a[1].push_back(2);
    a[2].push_back(1);
    /* 1과 3 연결 */
    a[1].push_back(3);
    a[3].push_back(1);
    /* 2와 3 연결 */
    a[2].push_back(3);
    a[3].push_back(2);
    /* 2와 4 연결 */
    a[2].push_back(4);
    a[4].push_back(2);
    /* 2와 5 연결 */
    a[2].push_back(5);
    a[5].push_back(2);
    /* 3과 6 연결 */
    a[3].push_back(6);
    a[6].push_back(3);
    /* 3과 7 연결 */
    a[3].push_back(7);
    a[7].push_back(3);
    /* 4와 5 연결 */
    a[4].push_back(5);
    a[5].push_back(4);
    /* 6과 7 연결 */
    a[6].push_back(7);
    a[7].push_back(6);
    /* DFS 수행 */
    dfs(1);
    return 0;
}

```

<br>

## Union-Find

대표적인 그래프 알고리즘 : 합집합 찾기 ( = 서로소 집합 알고리즘 )  
> 여러개의 노드가 존재할 때, 두개의 노드를 선택해서, 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘  

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day5/union_find.png?raw=true" width="500" height="300"></center>

여러 개의 노드가 서로 자유분방하게 존재한다고 생각. 모두 연결되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있을 때를 다음과 같이 표현.  
모든 값이 자기 자신을 가리키도록 만들기.  

|  노드 번호  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   부모 노드 번호  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |  

이때 1과 2가 '연결' 되었다고 하면, 이러한 '연결성'을 프로그래밍 언어로 어떻게 표현할 수 있을지에 대한 내용이 바로 Union-Find  

|  노드 번호  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   부모 노드 번호  |   1   |   1   |   3   |   4   |   5   |   6   |   7   |   8   |  

부모를 합칠 때는 일반적으로 더 작은 값쪽으로 합진다.

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day5/union_find_2.png?raw=true" width="500" height="300"></center>

|  노드 번호  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   부모 노드 번호  |   1   |   1   |   2   |   4   |   5   |   6   |   7   |   8   |  

1과 3이 연결되었는지 파악?  
: 1과 3은 부모가 각각 1과 2로 다르기 때문에 부모 노드만 보고는 한번에 파악할 수 없다. >>> 재귀 함수 사용  

부모 노드를 찾기 위해서, 먼저 3이 가리키고 있는 2를 찾는다.  
그러면 2의 부모가 1을 가리키고 있으므로, 결과적으로 3의 부모가 1인 것을 알 수 있다.  
Union-Find 의 연산이 다 수행되고 나면 다음과 같은 표가 구성된다.

|  노드 번호  |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   부모 노드 번호  |   1   |   1   |   1   |   4   |   5   |   6   |   7   |   8   |  

노드 1, 2, 3의 부모가 모두 1이기 때문에 이 3가지 노드는 모두 같은 그래프에 속한다고 할 수 있다.

> Find 알고리즘은 두 개의 노드의 부모 노드를 확인하여 현재 같은 집합에 속하는지 확인하는 알고리즘

```go

#include <stdio.h>

int getParent(int parent[], int x){
    if (parent[x] == x) return x;
    return parent[x] = getParent(parent, parent[x]);
}

/* 각 부모 노드를 합친다 */
void unionParent(int parent[], int a, int b){
    a = getParent(parent, a);
    b = getParent(parent, b);
    if (a < b) parent[b] = a;
    else parent[a] = b;
}

/* 같은 부모 노드를 가지는지 확인 */
int findParent(int parent[], int a, int b){
    a = getParent(parent, a);
    b = getParent(parent, b);
    if (a == b) return  1;
    else return 0;
}

int main(void){
    int parent[11];
    for (int i = 1 ; i <= 10 ; i++){
        parent[i] = i;
    }
    unionPrent(parent, 1, 2);
    unionPrent(parent, 2, 3);
    unionPrent(parent, 3, 4);
    unionPrent(parent, 4, 5);
    unionPrent(parent, 5, 6);
    unionPrent(parent, 6, 7);
    unionPrent(parent, 7, 8);
    printf("1과 5는 연결되어있나요 ? %d/n", findParent(parent, 1, 5));
    unionParent(parent, 1, 5);
    printf("1과 5는 연결되어있나요 ? %d/n", findParent(parent, 1, 5));
    
}

```

( Union-Find 는 다른 고급 그래프 알고리즘의 베이스가 된다는 점에서 반드시 익혀야 하는 내용!! )