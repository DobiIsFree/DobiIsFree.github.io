---
layout: default
title: "5일차"
tags: 모각코
comments : true
---

## 2019.01.14 ( 5일차 )

## <center>📝 계획 📝</center>  

- [ ] 알고리즘
    - [ ] Breath First Search
    - [ ] Depth First Search
    - [ ] Union-Find

***

## Breath First Search : 너비 우선 탐색

> 탐색 할 때, 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘
맹목적인 탐색을 하고자 할 때 사용
* 너비 우선 탐색은 '최단 경로'를 찾아준다는 점에서 최단 길이를 보장해야 할 때 많이 사용

BFS 는 맨 처음에 시작 노드 (Start Node)를 큐에 삽입하면서 시작.  
시작 노드를 방문했다고 '방문 처리'를 해주도록 한다.  

1. 큐에서 하나의 노드를 꺼낸다
2. 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입한다.  
( 위 과정을 반복 )  
가까운 노드들부터 탐색이 이루어진다.

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day5/BFS.png?raw=true" width="500" height="500"></center>

> 탐색이 이루어지는 순서 = 1, 2, 3, 4, 5, 6, 7


```go

#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int number = 7;
int c[7];
vector<int> a[8];

void bfs(int start){
    queue<int> q;
    q.push(start);
    c[start] = true;
    while(!q.empth()){
        int x = q.front();
        q.pop();
        printf("%d ", x);
        for (int i = 0 ; i <a[x].size() ; i++){
            int y = a[x][i];
            if(!c[y]){
                q.push(y);
                c[y] = true;
            }
        }
    }
}

int main(void){
    /* 1과 2 연결 */
    a[1].push_back(2);
    a[2].push_back(1);
    /* 1과 3 연결 */
    a[1].push_back(3);
    a[3].push_back(1);
    /* 2와 3 연결 */
    a[2].push_back(3);
    a[3].push_back(2);
    /* 2와 4 연결 */
    a[2].push_back(4);
    a[4].push_back(2);
    /* 2와 5 연결 */
    a[2].push_back(5);
    a[5].push_back(2);
    /* 3과 6 연결 */
    a[3].push_back(6);
    a[6].push_back(3);
    /* 3과 7 연결 */
    a[3].push_back(7);
    a[7].push_back(3);
    /* 4와 5 연결 */
    a[4].push_back(5);
    a[5].push_back(4);
    /* 6과 7 연결 */
    a[6].push_back(7);
    a[7].push_back(6);
    /* BFS 수행 */
    bfs(1);
    return 0;
}

```

BFS 는 너비를 우선으로 하여 탐색한다는 특성이 중요!, 이를 이용해 다른 알고리즘에 적용한다는 것이 핵심 (BFS는 그 자체로는 큰 의미가 없다)

<br>

## Depth First Search

깊이 우선 탐색은 탐색을 함에 있어 깊은 것을 우선적으로 하여 탐색하는 알고리즘.  
맹목적으로 각 노드를 탐색할 때 주로 사용, 너비 우선 탐색에서 큐가 사용되었다면 깊이 우선 탐색에서는 '스택' 사용 (스택을 사용하지 않아도 구현 가능 : 컴퓨터는 구조적으로 항상 스택의 원리 사용)

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day5/BFS.png?raw=true" width="500" height="500"></center>

DFS는 맨 처음 시작 노드를 스택에 삽입하면서 시작.  
그와 동시에 시작 노드를 방문했다고 알리는 '방문처리'를 해준다.  

1. 스택의 최상단 노드 확인
2. 최상단 노드에게 방문하지 않은 인접 노드가 있다면 그 노드를 스택에 넣고 방문처리. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드르 뺀다.  
( 반복 수행 )  

> 방문 경로 : 1, 2, 3, 6, 7, 4, 5

```go

#include <iostream>
#include <vector>

using namespace std;

int number = 7;
int c[8];
voector<int> a[8];

void dfs(int x){
    if(c[x]) return;
    c[x] = true;
    cout << x << ' ';
    for (int i = 0 ; i < a[x].size(); i++){
        int y = a[x][i];
        dfs(y);
    }
}

int main(void){
    /* 1과 2 연결 */
    a[1].push_back(2);
    a[2].push_back(1);
    /* 1과 3 연결 */
    a[1].push_back(3);
    a[3].push_back(1);
    /* 2와 3 연결 */
    a[2].push_back(3);
    a[3].push_back(2);
    /* 2와 4 연결 */
    a[2].push_back(4);
    a[4].push_back(2);
    /* 2와 5 연결 */
    a[2].push_back(5);
    a[5].push_back(2);
    /* 3과 6 연결 */
    a[3].push_back(6);
    a[6].push_back(3);
    /* 3과 7 연결 */
    a[3].push_back(7);
    a[7].push_back(3);
    /* 4와 5 연결 */
    a[4].push_back(5);
    a[5].push_back(4);
    /* 6과 7 연결 */
    a[6].push_back(7);
    a[7].push_back(6);
    /* DFS 수행 */
    dfs(1);
    return 0;
}

```

<br>

## Union-Find