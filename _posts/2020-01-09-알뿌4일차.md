---
layout: default
title: "4일차"
tags: 모각코
comments : true
---

## 2019.01.02 ( 4일차 )

## <center>📝 계획 📝</center>  

- [ ] 알고리즘
    - [ ] Counting Sort
    - [ ] Stack
    - [ ] Queue

***

## Counting Sort

다음 "5이하 자연수" 데이터들을 오름차순 정렬  
1 3 2 4 3 2 5 3 1 2 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1  

> '범위 조건' 이 있는 경우에 한해서 굉장히 빠른 알고리즘
> 시간 복잡도 O(N)  

* 계수 정렬 : '크기를 기준'으로 갯수만 세주면 되기 때문에 위치를 바꿀 필요가 없다. 모든 데이터에 한 번씩만 접근하면 된다는 점에서 매우 효율적

```go

#include <stdio.h>

int main(void){
    int temp;
    int count[6];
    int array[30] = {
        1, 3, 2, 4, 3, 2, 5, 3, 1, 2, 
        3, 4, 4, 3, 5, 1, 2, 3, 5, 2,
        3, 1, 4, 3, 5, 1, 2, 1, 1, 1
    };
    for ( int i = 1 ; i <= 5 ; i++){
        count[i] = 0;
    }
    for (int i = 0 ; i < 30 ; i++){
        count[array[i]]++;
    }
    for (int i = 1 ; i <= 5 ; i++){
        if(count[i] != 0){
            for (int j = 0 ; j < count[i] ; j++){
                printf("%d ", i);
            }
        }
    }
    return 0;
}

```

<br>
***  

## Stack & Queue

(자료구조에 더 가깝다 : 데이터의 기반 구조를 처리하는 방법에 대한 내용)  
스택 : 입구와 출구가 하나밖에 없는 상태

```go

#include <iostream>
#include <stack>

using namespace std;

int main(void){
    stack<int> s;
    s.push(7);
    s.push(5);
    s.push(4);
    s.pop();
    s.push(6);
    s.pop();
    while(!s.empty()){
        cout << s.top() << ' ';
        s.pop();
    }
    return 0;
}

```

큐 : 들어온 것이 먼저 나가는 구조 (First In First Out, FIFO)  
스택과 다르게 통로의 양 옆이 뚫려 있어

```go

#include <iostream>
#include <queue>

using namespace std;

int main(void){
   queue<int> q;
   q.push(7);
   q.push(5);
   q.push(4);
   q.pop();
   q.push(6);
   q.pop();
   while(!q.empth()){
       cout << q.front() << ' ';
       q.pop();
   }
    return 0;
}

```