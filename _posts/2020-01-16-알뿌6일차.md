---
layout: default
title: "6μΌμ°¨"
tags: λ¨κ°μ½”
comments : true
---

## 2019.01.16 ( 6μΌμ°¨ )

## <center>π“ κ³„ν π“</center>  

- [ ] μ•κ³ λ¦¬μ¦
    - [ ] Kruskal Algorithm
    - [ ] μ΄μ§„ νΈλ¦¬μ κµ¬ν„κ³Ό μν μ•κ³ λ¦¬μ¦
    - [ ] Dynamic Programming

***

## Kruskal Algorithm 

κ°€μ¥ μ μ€ λΉ„μ©μΌλ΅ λ¨λ“  λ…Έλ“λ¥Ό μ—°κ²°ν•κΈ° μ„ν•΄ μ‚¬μ©ν•λ” μ•κ³ λ¦¬μ¦  
( μµμ† μ‹ μ¥ νΈλ¦¬λ¥Ό λ§λ“¤κΈ° μ„ν• λ€ν‘μ μΈ μ•κ³ λ¦¬μ¦ )  
ex. μ—¬λ¬ κ°μ λ„μ‹κ°€ μμ„ λ•, κ° λ„μ‹λ¥Ό λ„λ΅λ¥Ό μ΄μ©ν•΄ μ—°κ²°ν•κ³ μ ν•  λ•, λΉ„μ©μ„ μµμ†ν•μΌλ΅ ν•κ³ μ ν•  λ• μ‹¤μ λ΅ μ μ©λλ” μ•κ³ λ¦¬μ¦  

> λ…Έλ“ = μ •μ  (= λ„μ‹) : κ·Έλν”„μ—μ„ λ™κ·ΈλΌλ―Έμ— ν•΄λ‹Ήν•λ” λ¶€λ¶„
> κ°„μ„  = κ±°λ¦¬ (= λΉ„μ©) : κ·Έλν”„μ—μ„ μ„ μ— ν•΄λ‹Ήν•λ” λ¶€λ¶„  

- ν¬λ¥΄μ¤μΉΌ μ•κ³ λ¦¬μ¦μ ν•µμ‹¬ κ°λ… ??  
> κ°„μ„ μ„ μ§§μ€ μμ„λ€λ΅ κ·Έλν”„μ— ν¬ν•¨μ‹ν‚¤λ©΄ μ–΄λ–¨κΉ?  

λ¨λ“  λ…Έλ“λ¥Ό μµλ€ν• μ μ€ λΉ„μ©μΌλ΅ 'μ—°κ²°λ§' μ‹ν‚¤λ©΄ λκΈ° λ•λ¬Έμ— λ¨λ“  κ°„μ„  μ •λ³΄λ¥Ό μ¤λ¦„μ°¨μμΌλ΅ μ •λ ¬ν• λ’¤μ— λΉ„μ©μ΄ μ μ€ κ°„μ„ λ¶€ν„° κ·Έλν”„μ— ν¬ν•¨μ‹ν‚¤λ©΄ λλ‹¤.  

λ¨λ“  κ°„μ„ λ“¤μ μ •λ³΄λ¥Ό μ €μ¥, κ±°λ¦¬(λΉ„μ©) κΈ°μ¤€μΌλ΅ λ¨Όμ € μ¤λ¦„μ°¨μ μ •λ ¬ μν–‰, μ•κ³ λ¦¬μ¦μ— λ§κ² κ·Έλν”„ μ—°κ²°ν•λ©΄ < μµμ† λΉ„μ© μ‹ μ¥ νΈλ¦¬ >μ™„μ„±  

1. μ •λ ¬λ μμ„μ— λ§κ² κ·Έλν”„μ— ν¬ν•¨μ‹ν‚¨λ‹¤.  
2. ν¬ν•¨μ‹ν‚¤κΈ° μ „μ—λ” μ‚¬μ΄ν΄ ν…μ΄λΈ”μ„ ν™•μΈν•λ‹¤.  
3. μ‚¬μ΄ν΄μ„ ν•μ„±ν•λ” κ²½μ° κ°„μ„ μ„ ν¬ν•¨ν•μ§€ μ•λ”λ‹¤.  
(μ‚¬μ΄ν΄ : κ·Έλν”„κ°€ μ„λ΅ μ—°κ²°λμ–΄ μ‚¬μ΄ν΄μ„ ν•μ„±ν•λ” κ²½μ° ; μµμ† λΉ„μ© μ‹ μ¥ νΈλ¦¬μ—μ„ μ‚¬μ΄ν΄μ΄ λ°μƒν•λ©΄ μ•λλ‹¤.)

```go

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

/* λ¶€λ¨ λ…Έλ“λ¥Ό κ°€μ Έμ΄ */
int getParent(int set[], int x){
    if (set[x] == x) return x;
    return set[x] = getParent(set, set[x]);
}

/* λ¶€λ¨ λ…Έλ“ λ³‘ν•© */
void unionParent(int set[], int a, int b){
    a = getParent(set, a);
    b = getParent(set, b);
    /* λ” μ«μκ°€ μ‘μ€ λ¶€λ¨λ΅ λ³‘ν•© */
    if (a < b) set[b] = a;
    else set[a] = b;
}

/* κ°™μ€ λ¶€λ¨λ¥Ό κ°€μ§€λ”μ§€ ν™•μΈ */
int find(int set[], int a, int b){
    a = getParent(set, a);
    b = getParent(set, b);
    if (a == b) return 1;
    else return 0;
}

/* κ°„μ„  ν΄λμ¤ μ„ μ–Έ */
class Edge{
    public : 
    int node[2];
    int distance;
    Edge (int a, int b, int distance){
        this -> node[0] = a;
        this -> node[1] = b;
        this -> distance = distance;
    }
    bool operator <(Edge &edge){
        return this->distance < edge.distance;
    }
};

int main(void){
    int n = 7;
    int m = 11;

    vector<Edge> v;
    v.push_back(Edge(1, 7, 12));
    v.push_back(Edge(1, 4, 28));
    v.push_back(Edge(1, 2, 67));
    v.push_back(Edge(1, 5, 17));
    v.push_back(Edge(2, 4, 24));
    v.push_back(Edge(2, 5, 62));
    v.push_back(Edge(3, 5, 20));
    v.push_back(Edge(3, 6, 37));
    v.push_back(Edge(4, 7, 13));
    v.push_back(Edge(5, 6, 45));
    v.push_back(Edge(5, 7, 73));
    
    /* κ°„μ„  λΉ„μ©μΌλ΅ μ¤λ¦„μ°¨μ μ •λ ¬ */
    sort(v.begin(), v.end());

    /* κ° μ •λ¤μ΄ ν¬ν•¨λ κ·Έλν”„κ°€ μ–΄λ””μΈμ§€ μ €μ¥ */
    int set[n];
    for (int i = 0 ; i < n ; i++){
        set[i] = i;
    }

    /* κ±°λ¦¬μ ν•©μ„ 0μΌλ΅ μ΄κΈ°ν™” */
    int sum = 0;
    for (int i = 0 ; i < v.size() ; i++){
        /* λ™μΌν• λ¶€λ¨λ¥Ό κ°€λ¥΄ν‚¤μ§€ μ•λ” κ²½μ°, μ‚¬μ΄ν΄μ΄ λ°μƒν•μ§€ μ•μ„ λ•λ§ μ„ νƒ */
        if (!find(set, v[i].node[0] - 1, v[i].node[1] - 1)) {
            sum += v[i].distance;
            unionParent(set, v[i].node[0] - 1, v[i].node - 1);
        }
    }
    printf("%d/n", sum);
}

```
<br>

***
<br>

## μ΄μ§„ νΈλ¦¬μ κµ¬ν„κ³Ό μν μ•κ³ λ¦¬μ¦

κΈ°λ³Έμ μΌλ΅ κ°€μ¥ λ§μ΄ μ‚¬μ©λλ” λΉ„μ„ ν• μλ£κµ¬μ΅° : μ΄μ§„ νΈλ¦¬(Binary Tree)  
μ΄μ§„ νΈλ¦¬λ” νΈλ¦¬ μλ£κµ¬μ΅°λ¥Ό ν™μ©ν• λ€ν‘μ μΈ μμ‹λ΅, λ°μ΄ν„°μ νƒμƒ‰ μ†λ„ μ¦μ§„μ„ μ„ν•΄ μ‚¬μ©ν•λ” κµ¬μ΅°. μ‹¤μ λ΅ νΈλ¦¬λ¥Ό μ λλ΅ κµ¬ν„ν•κΈ° μ„ν•΄μ„λ” ν¬μΈν„°(Pointer)λ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ‹¤. ν¬μΈν„°λ¥Ό μ΄μ©ν•΄ νΉμ •ν• λ£¨νΈ(Root)μ—μ„ μμ‹ λ…Έλ“λ΅ μ ‘κ·Όν•  μ μκΈ° λ•λ¬Έ.  

<br>

μ΄μ§„ νΈλ¦¬μ ν•λ‚μ λ…Έλ“λ” λ¨λ‘ μ™Όμ½ μμ‹κ³Ό μ¤λ¥Έμ½ μμ‹μ„ κ°€μ§ μ μλ„λ΅ μ„¤κ³„ λμ–΄μλ‹¤. 'ν¬μΈν„°'λ¥Ό μ‚¬μ©ν•μ§€ μ•μΌλ©΄ μ™„μ „ μ΄μ§„ νΈλ¦¬κ°€ μ•„λ‹ μ΄μ§„ νΈλ¦¬λ” λ°°μ—΄λ΅ ν‘ν„ν•κΈ° μ–΄λ µκΈ° λ•λ¬Έ  
ν¬μΈν„°λ¥Ό μ‚¬μ©ν•΄ μ΄μ§„ νΈλ¦¬λ¥Ό κµ¬ν„ν•λ” κ²½μ°, κµ‰μ¥ν μ λ™μ μΌλ΅ νΈλ¦¬ κµ¬μ΅°λ¥Ό ν™μ©ν•  μ μλ‹¤.  

- μ΄μ§„ νΈλ¦¬μ—μ„ λ°μ΄ν„°λ¥Ό μνν•λ” λ°©λ²• (3κ°€μ§€)
1. μ „μ„ μν (Preorder Traversal)
ν•λ‚μ λ…Έλ“μ— λ°©λ¬Έν–μ„ λ• λ‹¤μμ μμ„λ¥Ό λ”°λ¥Έλ‹¤.  
(1) λ¨Όμ € μκΈ° μμ‹ μ„ μ²λ¦¬ν•λ‹¤.  
(2) μ™Όμ½ μμ‹μ„ λ°©λ¬Έν•λ‹¤.  
(3) μ¤λ¥Έμ½ μμ‹μ„ λ°©λ¬Έν•λ‹¤.  

2. μ¤‘μ„ μν(Inorder Traversal)
(1) μ™Όμ½ μμ‹μ„ λ°©λ¬Έν•λ‹¤.
(2) λ¨Όμ € μκΈ° μμ‹ μ„ μ²λ¦¬ν•λ‹¤
(3) μ¤λ¥Έμ½ μμ‹μ„ λ°©λ¬Έν•λ‹¤.

3. ν›„μ„ μν(Postorder Traversal)
(1) μ™Όμ½ μμ‹μ„ λ°©λ¬Έν•λ‹¤.
(2) μ¤λ¥Έμ½ μμ‹μ„ λ°©λ¬Έν•λ‹¤.
(3) λ¨Όμ € μκΈ°μμ‹ μ„ μ²λ¦¬ν•λ‹¤.

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day6/Binary_Tree.png?raw=true" width="500" height="500"></center>

> μ „μ„ μν : 1 - 2 - 4 - 8 - 9 - 5 - 10 - 11 - 3 - 6 - 12 - 13 - 7 - 14 - 15
> μ¤‘μ„ μν : 8 - 4 - 9 - 2 - 10 - 5 - 11 - 1 - 12 - 6 - 13 - 3 - 14 - 7 -15
> ν›„μ„ μν : 8 - 9 - 4 - 10 - 11 - 5 - 2 - 12 - 13 - 6 - 14 - 15 - 7 - 3 - 1

```go

#include <iostream>

using namespace std;

int number = 15;

/* ν•λ‚μ λ…Έλ“ μ •λ³΄λ¥Ό μ„ μ–Έν•λ‹¤ */
typedef struct node *treePointer;
typedef struct node {
    int data;
    treePointer leftChild, rightChild;
} node;

/* μ „μ„ μν */
void preorder (treePointer ptr){
    if (ptr){
        cout << ptr-> data << ' ';
        preorder(ptr->leftChild);
        preorder(ptr->rightChild);
    }
}

/* μ¤‘μ„ μν */
void inorder(treePointer ptr){
    if (ptr){
        inorder(ptr->leftChild);
        cout << ptr-> data << ' ';
        preorder(ptr->rightChild);
    }
}

/* ν›„μ„ μν */
void postorder(treePointer ptr){
    if (ptr){
        inorder(ptr->leftChild);
        preorder(ptr->rightChild);
        cout << ptr-> data << ' ';
    }
}

int main(void){
    node nodes[number + 1];
    for (int i = 1 ; i <= number ; i++){
        nodes[i].data = i;
        nodes[i].leftChild = NULL;
        nodes[i].rightChild = NULL;
    }
    for (int i = 1 ; i <= number ; i++){
        if (i % 2 == 0)
            nodes[i / 2].leftChild = &nodes[i];
        else
            nodes[i / 2].rightChild = &nodes[i];
    }
    preorder(&nodes[1]);
    return 0;
}

```
