---
layout: default
title: "6ì¼ì°¨"
tags: ëª¨ê°ì½”
comments : true
---

## 2019.01.16 ( 6ì¼ì°¨ )

## <center>ğŸ“ ê³„íš ğŸ“</center>  

- [ ] ì•Œê³ ë¦¬ì¦˜
    - [ ] Kruskal Algorithm
    - [ ] ì´ì§„ íŠ¸ë¦¬ì˜ êµ¬í˜„ê³¼ ìˆœíšŒ ì•Œê³ ë¦¬ì¦˜
    - [ ] Dynamic Programming

***

## Kruskal Algorithm 

ê°€ì¥ ì ì€ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²°í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜  
( ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ëŒ€í‘œì ì¸ ì•Œê³ ë¦¬ì¦˜ )  
ex. ì—¬ëŸ¬ ê°œì˜ ë„ì‹œê°€ ìˆì„ ë•Œ, ê° ë„ì‹œë¥¼ ë„ë¡œë¥¼ ì´ìš©í•´ ì—°ê²°í•˜ê³ ì í•  ë•Œ, ë¹„ìš©ì„ ìµœì†Œí•œìœ¼ë¡œ í•˜ê³ ì í•  ë•Œ ì‹¤ì œë¡œ ì ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜  

> ë…¸ë“œ = ì •ì  (= ë„ì‹œ) : ê·¸ë˜í”„ì—ì„œ ë™ê·¸ë¼ë¯¸ì— í•´ë‹¹í•˜ëŠ” ë¶€ë¶„
> ê°„ì„  = ê±°ë¦¬ (= ë¹„ìš©) : ê·¸ë˜í”„ì—ì„œ ì„ ì— í•´ë‹¹í•˜ëŠ” ë¶€ë¶„  

- í¬ë¥´ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ ê°œë… ??  
> ê°„ì„ ì„ ì§§ì€ ìˆœì„œëŒ€ë¡œ ê·¸ë˜í”„ì— í¬í•¨ì‹œí‚¤ë©´ ì–´ë–¨ê¹Œ?  

ëª¨ë“  ë…¸ë“œë¥¼ ìµœëŒ€í•œ ì ì€ ë¹„ìš©ìœ¼ë¡œ 'ì—°ê²°ë§Œ' ì‹œí‚¤ë©´ ë˜ê¸° ë•Œë¬¸ì— ëª¨ë“  ê°„ì„  ì •ë³´ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë’¤ì— ë¹„ìš©ì´ ì ì€ ê°„ì„ ë¶€í„° ê·¸ë˜í”„ì— í¬í•¨ì‹œí‚¤ë©´ ëœë‹¤.  

ëª¨ë“  ê°„ì„ ë“¤ì˜ ì •ë³´ë¥¼ ì €ì¥, ê±°ë¦¬(ë¹„ìš©) ê¸°ì¤€ìœ¼ë¡œ ë¨¼ì € ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ ìˆ˜í–‰, ì•Œê³ ë¦¬ì¦˜ì— ë§ê²Œ ê·¸ë˜í”„ ì—°ê²°í•˜ë©´ < ìµœì†Œ ë¹„ìš© ì‹ ì¥ íŠ¸ë¦¬ >ì™„ì„±  

1. ì •ë ¬ëœ ìˆœì„œì— ë§ê²Œ ê·¸ë˜í”„ì— í¬í•¨ì‹œí‚¨ë‹¤.  
2. í¬í•¨ì‹œí‚¤ê¸° ì „ì—ëŠ” ì‚¬ì´í´ í…Œì´ë¸”ì„ í™•ì¸í•œë‹¤.  
3. ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ê²½ìš° ê°„ì„ ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.  
(ì‚¬ì´í´ : ê·¸ë˜í”„ê°€ ì„œë¡œ ì—°ê²°ë˜ì–´ ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ê²½ìš° ; ìµœì†Œ ë¹„ìš© ì‹ ì¥ íŠ¸ë¦¬ì—ì„œ ì‚¬ì´í´ì´ ë°œìƒí•˜ë©´ ì•ˆëœë‹¤.)

```go

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

/* ë¶€ëª¨ ë…¸ë“œë¥¼ ê°€ì ¸ì˜´ */
int getParent(int set[], int x){
    if (set[x] == x) return x;
    return set[x] = getParent(set, set[x]);
}

/* ë¶€ëª¨ ë…¸ë“œ ë³‘í•© */
void unionParent(int set[], int a, int b){
    a = getParent(set, a);
    b = getParent(set, b);
    /* ë” ìˆ«ìê°€ ì‘ì€ ë¶€ëª¨ë¡œ ë³‘í•© */
    if (a < b) set[b] = a;
    else set[a] = b;
}

/* ê°™ì€ ë¶€ëª¨ë¥¼ ê°€ì§€ëŠ”ì§€ í™•ì¸ */
int find(int set[], int a, int b){
    a = getParent(set, a);
    b = getParent(set, b);
    if (a == b) return 1;
    else return 0;
}

/* ê°„ì„  í´ë˜ìŠ¤ ì„ ì–¸ */
class Edge{
    public : 
    int node[2];
    int distance;
    Edge (int a, int b, int distance){
        this -> node[0] = a;
        this -> node[1] = b;
        this -> distance = distance;
    }
    bool operator <(Edge &edge){
        return this->distance < edge.distance;
    }
};

int main(void){
    int n = 7;
    int m = 11;

    vector<Edge> v;
    v.push_back(Edge(1, 7, 12));
    v.push_back(Edge(1, 4, 28));
    v.push_back(Edge(1, 2, 67));
    v.push_back(Edge(1, 5, 17));
    v.push_back(Edge(2, 4, 24));
    v.push_back(Edge(2, 5, 62));
    v.push_back(Edge(3, 5, 20));
    v.push_back(Edge(3, 6, 37));
    v.push_back(Edge(4, 7, 13));
    v.push_back(Edge(5, 6, 45));
    v.push_back(Edge(5, 7, 73));
    
    /* ê°„ì„  ë¹„ìš©ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ */
    sort(v.begin(), v.end());

    /* ê° ì •ë¤ì´ í¬í•¨ëœ ê·¸ë˜í”„ê°€ ì–´ë””ì¸ì§€ ì €ì¥ */
    int set[n];
    for (int i = 0 ; i < n ; i++){
        set[i] = i;
    }

    /* ê±°ë¦¬ì˜ í•©ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™” */
    int sum = 0;
    for (int i = 0 ; i < v.size() ; i++){
        /* ë™ì¼í•œ ë¶€ëª¨ë¥¼ ê°€ë¥´í‚¤ì§€ ì•ŠëŠ” ê²½ìš°, ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•Šì„ ë•Œë§Œ ì„ íƒ */
        if (!find(set, v[i].node[0] - 1, v[i].node[1] - 1)) {
            sum += v[i].distance;
            unionParent(set, v[i].node[0] - 1, v[i].node - 1);
        }
    }
    printf("%d/n", sum);
}

```
<br>

***
<br>
## ì´ì§„ íŠ¸ë¦¬ì˜ êµ¬í˜„ê³¼ ìˆœíšŒ ì•Œê³ ë¦¬ì¦˜
