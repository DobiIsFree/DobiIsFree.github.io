---
layout: default
title: "6일차"
tags: 모각코
comments : true
---

## 2019.01.16 ( 6일차 )

## <center>📝 계획 📝</center>  

- [ ] 알고리즘
    - [ ] Kruskal Algorithm
    - [ ] 이진 트리의 구현과 순회 알고리즘
    - [ ] Dynamic Programming

***

## Kruskal Algorithm 

가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘  
( 최소 신장 트리를 만들기 위한 대표적인 알고리즘 )  
ex. 여러 개의 도시가 있을 때, 각 도시를 도로를 이용해 연결하고자 할 때, 비용을 최소한으로 하고자 할 때 실제로 적용되는 알고리즘  

> 노드 = 정점 (= 도시) : 그래프에서 동그라미에 해당하는 부분
> 간선 = 거리 (= 비용) : 그래프에서 선에 해당하는 부분  

- 크르스칼 알고리즘의 핵심 개념 ??  
> 간선을 짧은 순서대로 그래프에 포함시키면 어떨까?  

모든 노드를 최대한 적은 비용으로 '연결만' 시키면 되기 때문에 모든 간선 정보를 오름차순으로 정렬한 뒤에 비용이 적은 간선부터 그래프에 포함시키면 된다.  

모든 간선들의 정보를 저장, 거리(비용) 기준으로 먼저 오름차순 정렬 수행, 알고리즘에 맞게 그래프 연결하면 < 최소 비용 신장 트리 >완성  

1. 정렬된 순서에 맞게 그래프에 포함시킨다.  
2. 포함시키기 전에는 사이클 테이블을 확인한다.  
3. 사이클을 형성하는 경우 간선을 포함하지 않는다.  
(사이클 : 그래프가 서로 연결되어 사이클을 형성하는 경우 ; 최소 비용 신장 트리에서 사이클이 발생하면 안된다.)

```go

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

/* 부모 노드를 가져옴 */
int getParent(int set[], int x){
    if (set[x] == x) return x;
    return set[x] = getParent(set, set[x]);
}

/* 부모 노드 병합 */
void unionParent(int set[], int a, int b){
    a = getParent(set, a);
    b = getParent(set, b);
    /* 더 숫자가 작은 부모로 병합 */
    if (a < b) set[b] = a;
    else set[a] = b;
}

/* 같은 부모를 가지는지 확인 */
int find(int set[], int a, int b){
    a = getParent(set, a);
    b = getParent(set, b);
    if (a == b) return 1;
    else return 0;
}

/* 간선 클래스 선언 */
class Edge{
    public : 
    int node[2];
    int distance;
    Edge (int a, int b, int distance){
        this -> node[0] = a;
        this -> node[1] = b;
        this -> distance = distance;
    }
    bool operator <(Edge &edge){
        return this->distance < edge.distance;
    }
};

int main(void){
    int n = 7;
    int m = 11;

    vector<Edge> v;
    v.push_back(Edge(1, 7, 12));
    v.push_back(Edge(1, 4, 28));
    v.push_back(Edge(1, 2, 67));
    v.push_back(Edge(1, 5, 17));
    v.push_back(Edge(2, 4, 24));
    v.push_back(Edge(2, 5, 62));
    v.push_back(Edge(3, 5, 20));
    v.push_back(Edge(3, 6, 37));
    v.push_back(Edge(4, 7, 13));
    v.push_back(Edge(5, 6, 45));
    v.push_back(Edge(5, 7, 73));
    
    /* 간선 비용으로 오름차순 정렬 */
    sort(v.begin(), v.end());

    /* 각 정덤이 포함된 그래프가 어디인지 저장 */
    int set[n];
    for (int i = 0 ; i < n ; i++){
        set[i] = i;
    }

    /* 거리의 합을 0으로 초기화 */
    int sum = 0;
    for (int i = 0 ; i < v.size() ; i++){
        /* 동일한 부모를 가르키지 않는 경우, 사이클이 발생하지 않을 때만 선택 */
        if (!find(set, v[i].node[0] - 1, v[i].node[1] - 1)) {
            sum += v[i].distance;
            unionParent(set, v[i].node[0] - 1, v[i].node - 1);
        }
    }
    printf("%d/n", sum);
}

```
<br>

***
<br>

## 이진 트리의 구현과 순회 알고리즘

기본적으로 가장 많이 사용되는 비선형 자료구조 : 이진 트리(Binary Tree)  
이진 트리는 트리 자료구조를 활용한 대표적인 예시로, 데이터의 탐색 속도 증진을 위해 사용하는 구조. 실제로 트리를 제래로 구현하기 위해서는 포인터(Pointer)를 사용해야 한다. 포인터를 이용해 특정한 루트(Root)에서 자식 노드로 접근할 수 있기 때문.  

<br>

이진 트리의 하나의 노드는 모두 왼쪽 자식과 오른쪽 자식을 가질 수 있도록 설계 되어있다. '포인터'를 사용하지 않으면 완전 이진 트리가 아닌 이진 트리는 배열로 표현하기 어렵기 때문  
포인터를 사용해 이진 트리를 구현하는 경우, 굉장히 유동적으로 트리 구조를 활용할 수 있다.  

- 이진 트리에서 데이터를 순회하는 방법 (3가지)
1. 전위 순회 (Preorder Traversal)
하나의 노드에 방문했을 때 다음의 순서를 따른다.  
(1) 먼저 자기 자신을 처리한다.  
(2) 왼쪽 자식을 방문한다.  
(3) 오른쪽 자식을 방문한다.  

2. 중위 순회(Inorder Traversal)
(1) 왼쪽 자식을 방문한다.
(2) 먼저 자기 자신을 처리한다
(3) 오른쪽 자식을 방문한다.

3. 후위 순회(Postorder Traversal)
(1) 왼쪽 자식을 방문한다.
(2) 오른쪽 자식을 방문한다.
(3) 먼저 자기자신을 처리한다.

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day6/Binary_Tree.png?raw=true" width="500" height="500"></center>

> 전위 순회 : 1 - 2 - 4 - 8 - 9 - 5 - 10 - 11 - 3 - 6 - 12 - 13 - 7 - 14 - 15
> 중위 순회 : 8 - 4 - 9 - 2 - 10 - 5 - 11 - 1 - 12 - 6 - 13 - 3 - 14 - 7 -15
> 후위 순회 : 8 - 9 - 4 - 10 - 11 - 5 - 2 - 12 - 13 - 6 - 14 - 15 - 7 - 3 - 1

```go

#include <iostream>

using namespace std;

int number = 15;

/* 하나의 노드 정보를 선언한다 */
typedef struct node *treePointer;
typedef struct node {
    int data;
    treePointer leftChild, rightChild;
} node;

/* 전위 순회 */
void preorder (treePointer ptr){
    if (ptr){
        cout << ptr-> data << ' ';
        preorder(ptr->leftChild);
        preorder(ptr->rightChild);
    }
}

/* 중위 순회 */
void inorder(treePointer ptr){
    if (ptr){
        inorder(ptr->leftChild);
        cout << ptr-> data << ' ';
        preorder(ptr->rightChild);
    }
}

/* 후위 순회 */
void postorder(treePointer ptr){
    if (ptr){
        inorder(ptr->leftChild);
        preorder(ptr->rightChild);
        cout << ptr-> data << ' ';
    }
}

int main(void){
    node nodes[number + 1];
    for (int i = 1 ; i <= number ; i++){
        nodes[i].data = i;
        nodes[i].leftChild = NULL;
        nodes[i].rightChild = NULL;
    }
    for (int i = 1 ; i <= number ; i++){
        if (i % 2 == 0)
            nodes[i / 2].leftChild = &nodes[i];
        else
            nodes[i / 2].rightChild = &nodes[i];
    }
    preorder(&nodes[1]);
    return 0;
}

```
