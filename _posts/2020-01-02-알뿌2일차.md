---
layout: default
title: "2일차"
tags: 모각코
comments : true
---

## 2019.01.02 ( 2일차 )

## <center>📝 계획 📝</center>  

- [ ] 알고리즘
    - [ ] VSCode : C++ 작업 환경 설정하기
    - [ ] 정렬
        - [ ] 선택 정렬
        - [ ] 버블 정렬
        - [ ] 삽입 정렬
        - [ ] 퀵 정렬
        - [ ] 병합 정렬
    - [ ] 기초 정렬 알고리즘 문제 풀이

***

- vscode 한글로 바꾸고 c++을 위한 프로그램? 설치
- 디버깅이랑 다른 작업을 위해 뭔가 더 설치할게 남은것 같지만 잘 모르겠다.  
일단 직접 사용하면서 추가로 설치하기로

<br>

## 1. 선택 정렬 ( Selection Sort )


<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/1.jpeg?raw=true" width="500" height="500"></center>

code :  


```go
/* selectionSort.cpp */

#include <iostream>

int main(void){
    int i, j, min, index, temp;
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for (i = 0 ; i < 10 ; i++){
        min = 9999;
        for(j = i ; j < 10 ; j++){
            if (min > array[j]){
                min = array[j];
                index = j;
            }
        }
        temp = array[i];
        array[i] = array[index];
        array[index] = temp;
    }
    for(i = 0 ; i < 10 ; i++){
        printf("%d ", array[i]);
    }
    return 0;
}
```
결과 : 
<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/result_selection.png?raw=true" width="500" height="70"></center>



<br>

- 선택 정렬이 얼마나 많은 시간을 잡아먹는가 ??
위의 예제에서 10개의 수를 정렬하는데 처음 수 ~ 마지막 수 까지  
10 + 9 + 8 + 7 + ... + 1 번의 정렬 거쳐  
= 10 * ( 10 + 1 ) / 2 = 55  

> N * ( N + 1) / 2

N이 크다는 가정 하에 나누거나 더하는 것은 의미가 사라진다

> N * N  
> O(N^2)

비효율적인 정렬!

## 2. 버블 정렬 ( Bubble Sort )

(오름차순으로 정렬하는 프로그램 만들기)  

> 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내기
구현하기 가장 쉽지만 효율성은 가장 떨어진다.

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/bubble.jpeg?raw=true" width="500" height="500"></center>

- 버블 정렬의 시간 복잡도
한번 반복할 때마다 집합의 크기 줄어들어  
10 + 9 + 8 + ... + 1  
= 10 * ( 10 + 1) / 2  
= 55  

> N * N  
> O(N^2)

실제 작동 시키면 선택 정렬보다 훨씬 느리게 작동한다.  
이유 : 당장 옆에 있는 것부터 시작해서 자리를 바꾸는 연산 (3개의 명령) 시작  
매번 교체하는 연산이 실행되는 점에서 시간이 걸린다.  

Code : 

```go
/* bubbleSort.cpp */

#include <iostream>

int main(void){
    int i, j, temp;
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for(i = 0 ; i < 10 ; i++){
        for(j = 0 ; j < 9 - i ; j++){
            if(array[j] > array[j + 1]){
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
    for(i = 0 ; i < 10 ; i++){
        printf("%d ", array[i]);
    }
    return 0;
}
```
<br>
결과 : 
<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/result_bubble.png?raw=true" width="500" height="50"></center>

## 3. 삽입 정렬 ( Insertion Sort )
(오름차순으로 정렬하는 프로그램 작성)  
> 각 숫자를 적절한 위치에 삽입하기  

<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/insertion.jpeg?raw=true" width="500" height="500"></center>

버블 정렬의 경우 이미 정렬이 이루어진 상태라도 위치를 바꾼다.  
삽입 정렬의 경우 정렬이 필요할 때만 위치 바꿈이 일어난다.  
이미 정렬되었다고 " 가정 " (특정한 경우에 따라 굉장히 빠른 속도를 자랑한다.)  

> 최악의 경우 O(N*N)

Code : 
```go
/* insertionSort.cpp */

#include <iostream>

int main(void){
    int i, j, min, index, temp;
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for (i = 0 ; i < 9 ; i++){
        j = i;
        while(array[j] > array[j + 1]){
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
            j--;
        }
    }
    for(i = 0 ; i < 10 ; i++){
        printf("%d ", array[i]);
    }
    return 0;
}
```

결과 : 
<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/result_insertion.png?raw=true" width="500" height="50"></center>


## 4. 퀵 정렬 ( Quick Sort )

### (1) 시간 복잡도와 작동 원리

분할 정복 알고리즘을 사용한다. 특정 배열을 반복적으로 분할,  
배열의 원소를 나누어 계산한다는 점에서 더 빠른 알고리즘이다.  
> 특정한 값을 기준으로 큰 숫자와 작은 숫자로 나눈다.  
> 평균 속도 : O(N * logN)


### (2) 구현 및 한계점 분석

> 최악 시간 복잡도 O(N*N)

Code : 
```go
/* quickSort.cpp */

#include <iostream>

int number = 10;
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void show(){
    int i;
    for(i = 0; i < number; i++){
        printf("%d ", data[i]);
    }
}

void quickSort(int* data, int start, int end){
    if(start >= end){   
        return;
    }

    int key = start;    
    int i = start + 1;
    int j = end;
    int temp;

    while(i <= j){      
        while(i <= end && data[i] <= data[key]){
            i++;
        }
        while(j > start && data[j] >= data[key]){
            j--;
        }
        if(i > j){
            temp = data[j];
            data[j] = data[key];
            data[key] = temp;
        }
        else{
            temp = data[i];
            data[i] = data[j];
            data[j] = temp;
        }
    }
    quickSort(data, start, j - 1);
    quickSort(data, j + 1, end);
}

int main(void){
    quickSort(data, 0, number - 1);
    show();
    return 0;
}
```

결과 : 
<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/result_quick.png?raw=true" width="500" height="50"></center>

- 내림차순으로 변경하기
```go
/* quickSort.cpp */

#include <iostream>

int number = 10;
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void show(){
    int i;
    for(i = 0; i < number; i++){
        printf("%d ", data[i]);
    }
}

void quickSort(int* data, int start, int end){
    if(start >= end){   
        return;
    }

    int key = start;    
    int i = start + 1;
    int j = end;
    int temp;

    while(i <= j){      
        while(i <= end && data[i] >= data[key]){    // 부호 변화
            i++;
        }
        while(j > start && data[j] <= data[key]){
            j--;
        }
        if(i > j){
            temp = data[j];
            data[j] = data[key];
            data[key] = temp;
        }
        else{
            temp = data[i];
            data[i] = data[j];
            data[j] = temp;
        }
    }
    quickSort(data, start, j - 1);
    quickSort(data, j + 1, end);
}

int main(void){
    quickSort(data, 0, number - 1);
    show();
    return 0;
}
```



## 5. 병합 정렬 ( Merge Sort )

분할 정복 알고리즘 사용. 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간 복잡도를 가진다.  
다만 퀵 정렬은 피벗 값에 따라 편향되게 분할할 가능성이 있다는 점에서 최악의 경우 O(N^2)의 시간 복잡도를 가진다.  
병합 정렬은 정확이 절반씩 나눈다는 점에서 최악의 경우에도 O(N*logN)을 보장한다.

> 일단 반으로 나누고 나중에 합쳐서 정렬

Code : 
```go
/* mergeSort.cpp */

#include <iostream>

# define number 8
int sorted[8];

void merge(int a[], int m, int middle, int n){
    int i = m;
    int j = middle + 1;
    int k = m;
    while(i <= middle && j <= n){
        if(a[i] <= a[j]){
            sorted[k] = a[i];
            i++;
        }
        else{
            sorted[k] = a[j];
            j++;
        }
        k++;
    }
    if(i > middle){
        for(int t = j ; t <= n ; t++){
            sorted[k] = a[t];
            k++;
        }
    }
    else {
        for (int t = i ; t <= middle ; t++){
            sorted[k] = a[t];
            k++;
        }
    }
    for(int t = m ; t <= n ; t++){
        a[t] = sorted[t];
    }
}

void mergeSort(int a[], int m, int n){
    if(m < n){
        int middle = (m + n) / 2;
        mergeSort(a, m, middle);
        mergeSort(a, middle + 1, n);
        merge(a, m, middle, n);
    }
}

int main(void) {
    int array[number] = {7, 6, 5, 8, 3, 5, 9, 1};
    mergeSort(array, 0, number - 1);
    for(int i = 0 ; i < number ; i++){
        printf("%d ", array[i]);
    }
}
```

결과 : 
<center><img src="https://github.com/DobiIsFree/DobiIsFree.github.io/blob/master/photos/day2/result_merge.png?raw=true" width="500" height="50"></center>

## 6. 기초 정렬 알고리즘 문제 풀이